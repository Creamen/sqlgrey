#!/usr/bin/perl -w

# sqlgrey: a postfix greylisting policy server using an SQL backend
# based on postgrey
# Copyright 2004 (c) ETH Zurich
# Copyright 2004 (c) Lionel Bouton

#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# see the documentation with 'perldoc sqlgrey'

package sqlgrey;
use strict;
use Pod::Usage;
use Getopt::Long 2.25 qw(:config posix_default no_ignore_case);
use Net::Server::Multiplex;
use DBI;

use vars qw(@ISA);
@ISA = qw(Net::Server::Multiplex);

my $VERSION = "1.4.7";
my $software = 'SQLgrey-' . "$VERSION";

my $DB_VERSION = 1;

# Table names
my $connect       = 'connect';
my $from_awl      = 'from_awl';
my $domain_awl    = 'domain_awl';
my $config        = 'config';

# defaults
my %dflt;
$dflt{quiet}              = undef;
$dflt{verbose}            = undef;
$dflt{debug}              = undef;
$dflt{user}               = 'sqlgrey';
$dflt{group}              = 'sqlgrey';
$dflt{inet}               = '2501';
$dflt{pidfile}            = '/var/run/sqlgrey.pid';
$dflt{reconnect_delay}    = 1;            # 1 minute
$dflt{max_connect_age}    = 24;           # 24 hours
$dflt{awl_age}            = 60;           # 60 days
$dflt{group_domain_level} = 2;            # 2 e-mail addr from same domain/IP
$dflt{reject_first_attempt} = 'delay';    # Use 'delay' or 'immed'
$dflt{reject_early_reconnect} = undef;    # Leave undef
$dflt{db_type}            = 'Pg';
$dflt{db_name}            = 'sqlgrey';
$dflt{db_host}            = 'localhost';
$dflt{db_user}            = 'sqlgrey';
$dflt{db_pass}            = '';
$dflt{prepend}            = 1;
$dflt{greymethod}         = 'smart';
$dflt{db_cleandelay}	  = 30 * 60;
$dflt{admin_mail}         = '';

# Default configuration file
my $config_file           = '/etc/sqlgrey/sqlgrey.conf';
# whitelist files
my $stat_ip_whitelist_file = '/etc/sqlgrey/clients_ip_whitelist';
my $dyn_ip_whitelist_file = '/etc/sqlgrey/clients_ip_whitelist.local';
my $stat_fqdn_whitelist_file = '/etc/sqlgrey/clients_fqdn_whitelist';
my $dyn_fqdn_whitelist_file = '/etc/sqlgrey/clients_fqdn_whitelist.local';

my $prepend = 'PREPEND X-Greylist: ';

my $reload = 0; # used to signal a whitelists reload request

# Send mails
sub sendmail {
    my $self = shift;
    my $subject = shift;
    my $content = shift;
    my $now = time;

    # this code throttles the message rate
    # fill bucket
    $self->{sqlgrey}{mail_bucket} += ($now - $self->{sqlgrey}{last_mail})/
	(60*$self->{sqlgrey}{mail_period});
    $self->{sqlgrey}{last_mail} = $now;
    # but no more than its capacity
    $self->{sqlgrey}{mail_bucket} = $self->{sqlgrey}{mail_bucket} < $self->{sqlgrey}{mail_maxbucket} ?
	$self->{sqlgrey}{mail_bucket} : $self->{sqlgrey}{mail_maxbucket};

    $self->log(4, "mail_bucket: $self->{sqlgrey}{mail_bucket}");
    # is there room for a mail ?
    if ($self->{sqlgrey}{mail_bucket} >= 1) {
	if ($self->{sqlgrey}{mail_bucket} < 2) {
	    $content .= " (max warn message rate hit, throttling)";
	}

        # actual mail sending
        my $return = system("echo '$content' | mail -s '$subject' $self->{sqlgrey}{admin_mail}");
	if ($return != 0) {
	    if ($? == -1) {
		$self->log(2, "failed to send mail: $!\n");
	    } elsif ($? & 127) {
		$self->log(2, sprintf("send mail child died with " .
				      "signal %d, %s coredump\n",
				      ($? & 127),  ($? & 128) ?
				      'with' : 'without'));
	    } else {
		$self->log(2, sprintf("send mail child exited with value %d\n",
				      $? >> 8));
	    }
	}
	# empty bucket
	$self->{sqlgrey}{mail_bucket}--;
    }
}

sub mydie {
    my $self = shift;
    my $error = shift;
    $self->sendmail('SQLgrey died', $error);
    die $error;
}

##########################
## Database helper subs ##
##########################

# Trigger e-mails when the DB connection's state changes
sub db_unavailable {
    my $self = shift;

    if ($self->{sqlgrey}{db_available}) {
	$self->{sqlgrey}{warn_db} && $self->sendmail('SQLgrey lost DB',
			'SQLgrey lost connection to: ' . $self->cnctinfo());
	$self->{sqlgrey}{db_available} = 0;
    }
}

sub db_available {
    my $self = shift;

    if (! $self->{sqlgrey}{db_available}) {
	$self->{sqlgrey}{warn_db} && $self->sendmail('SQLgrey recovered DB',
			'SQLgrey established connection to: ' . $self->cnctinfo());
	$self->{sqlgrey}{db_available} = 1;
    }
}

# fault (lost connection) tolerant do
# allows a RDBMs restart without crash
sub do {
    my $self = shift;
    my $query = shift;
    my $result;

    if (! $self->{sqlgrey}{db_available}) {
	$self->connectdb();
    }
    if (!defined $self->{sqlgrey}{dbh} or
	!($result = $self->{sqlgrey}{dbh}->do($query))) {
	# failure
	$self->db_unavailable();
        $self->log(1, "Warning: couldn't do query:\n" .
		   "$query:\n" .
		   "$DBI::errstr, reconnecting to DB");
	return undef;
    } else {
	$self->db_available();
	return $result;
    }
}

# prepare_cached needs to check for a dbh
sub prepare_cached {
    my $self = shift;
    my $query = shift;

    if (! $self->{sqlgrey}{db_available}) {
	$self->connectdb();
    }
    if (!defined $self->{sqlgrey}{dbh}) {
	$self->db_unavailable();
	return undef;
    } else {
	my $result = $self->{sqlgrey}{dbh}->prepare_cached($query);
	if (! defined $result) {
	    $self->db_unavailable();
	} else {
	    $self->db_available();
	}
	return $result;
    }
}

# quote can't be called directly when dbh is undef
# we provide a wrapper
# we don't try to reconnect here
sub quote {
    my $self = shift;
    my $toquote = shift;
    if (! defined $self->{sqlgrey}{dbh}) {
	return "NULL";
    } else {
	return $self->{sqlgrey}{dbh}->quote($toquote);
    }
}

# Check if a table exists
sub table_exists {
    my $self = shift;
    my $tablename = shift;
    # Seems the most portable way to do it
    # but needs SQL error reporting off at connect time :-<
    $self->do("SELECT 1 from $tablename LIMIT 0")
        or return 0;
    return 1;
}

# INTERVAL syntax is platform dependant
sub interval {
    my ($self, $nb, $unit) = @_;
    my $db_type = $self->{sqlgrey}{db_type};
    if ($db_type eq 'mysql') {
	# MySQL doesn't want any ' char
        return "INTERVAL $nb $unit";
    } elsif ($db_type eq 'SQLite') {
	# SQLite doesn't recognise INTERVAL
        if ($unit eq 'DAY') {
            return $nb * 24 * 60 * 60;
        } elsif ($unit eq 'HOUR') {
            return $nb * 60 * 60;
        } elsif ($unit eq 'MINUTE') {
            return $nb * 60;
        } else {
            # catch syntax errors
            mydie 'interval(' . $nb . ', ' . $unit . ') for SQLite,'
		. " sqlgrey doesn't recognise $unit UNIT\n";
        }
    } else { # use PostgreSQL syntax (probably the most SQL compliant)
        return "INTERVAL '" . "$nb $unit" . "'";
    }
}

# Create tables if not done already
sub database_setup {
    my $self = shift;

    my $wasempty = 1;
    my $wasfull = 1;
    if (! $self->table_exists("$from_awl")) {
	$self->create_from_awl_table();
	$wasfull = 0; } else { $wasempty = 0; }
    if (! $self->table_exists("$domain_awl")) {
	$self->create_domain_awl_table();
	$wasfull = 0; } else { $wasempty = 0; }
    if (! $self->table_exists("$connect")) {
	$self->create_connect_table();
	$wasfull = 0; } else { $wasempty = 0, }

    if ($self->currentdbversion($wasempty) < $DB_VERSION) {
	$self->log(1, "Upgrading database from " .
		   $self->currentdbversion($wasempty) . " to " .
		   $DB_VERSION);
	$self->upgradedb();
    }

    # if upgradedb wasn't run ($wasempty eq 1)
    # we must create the config table
    if (! $self->table_exists("$config")) {
	$self->create_config_table();
	$self->setconfig('version',$DB_VERSION);
    }
    # database errors were masked until now
    $self->{sqlgrey}{warn_db} = 1;
}

sub getconfig {
    my $self = shift;
    my $param = shift;

    my $sth = $self->prepare_cached("SELECT value FROM $config " .
				    "WHERE parameter = ?");
    if (!defined $sth or !$sth->execute($param)) {
	$self->log(1, "Error: couldn't access $config table: $DBI::errstr");
	mydie "Can't continue: config table unreadable\n";
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
        $self->log(1, "Error: unexpected SQL result");
	mydie "Can't continue: unexpected config table read error\n";
    } else {
        return $result->[0][0];
    }
}

# Database configuration related, only used for checking
# schema version now, might be used to check compatibility
# between database schema and SQLgrey startup switches in the future
sub setconfig {
    my $self = shift;
    my $param = shift;
    my $value = shift;

    my $sth = $self->prepare_cached("SELECT value FROM $config " .
				    "WHERE parameter = ?");
    if (!defined $sth or !$sth->execute($param)) {
	$self->log(1, "Error: couldn't access $config table: $DBI::errstr");
	mydie "Can't continue: config table unreadable\n";
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
	# not a single value (should mean no value, not multiple ones)
	$self->insertconfig($param, $value);
    } else {
	$self->updateconfig($param, $value);
    }
}

sub updateconfig {
    my $self = shift;
    my $param = shift;
    my $value = shift;
    my $dbh = $self->{sqlgrey}{dbh};

    return $self->do("UPDATE $config SET value = " .
		     $self->quote($value) .
		     " WHERE parameter = " .
		     $self->quote($param));
}

sub insertconfig() {
    my $self = shift;
    my $param = shift;
    my $value = shift;
    my $dbh = $self->{sqlgrey}{dbh};

    return $self->do("INSERT INTO $config (parameter, value) VALUES(" .
		     $self->quote($param) . "," .
		     $self->quote($value) . ")");
}

sub currentdbversion() {
    my $self = shift;
    my $wasempty = shift;

    # Empty DB -> it is created with current version
    if ($wasempty) {
	return $DB_VERSION;
    }

    # No config table -> version 0
    if (! $self->table_exists("$config")) {
	return 0;
    }

    # Common case: read from config table
    return $self->getconfig('version');
}

sub upgradedb() {
    my $self = shift;
    my $currentdbver = $self->currentdbversion();
    while ($currentdbver < $DB_VERSION) {
	$self->upgrade($currentdbver);
	$currentdbver++;
    }
}

sub upgrade() {
    my $self = shift;
    my $ver = shift;
    if ($ver eq 0) {
	$self->upgrade0();
    }
}

sub upgrade0() {
    my $self = shift;
    my $db_type = $self->{sqlgrey}{db_type};
    $self->log(1, "Upgrading database schema from version 0 to version 1");
    if ($db_type ne "SQLite") {
	# 0 -> 1 : char to varchar
	# rename current table and dump content into new ones

	# connect
	$self->log(1, "CHAR -> VARCHAR in $connect table");
	$self->do("ALTER TABLE $connect RENAME TO $connect" . "old");
	$self->create_connect_table();
	$self->do("INSERT INTO $connect (sender_name, sender_domain, " .
		  "ip_addr, rcpt, first_seen) " .
		  "SELECT sender_name, sender_domain, ip_addr, " .
		  "rcpt, first_seen " .
		  "FROM $connect" . "old");
	$self->do("DROP TABLE $connect" . "old");

	# from_awl
	$self->log(1, "CHAR -> VARCHAR in $from_awl table");
	$self->do("ALTER TABLE $from_awl RENAME TO $from_awl" . "old");
	if ($db_type eq 'Pg') {
	    # we need to remove the pkey constraint
	    $self->do("ALTER TABLE $from_awl" . "old DROP CONSTRAINT " .
		      "from_awl_pkey");
	}
	$self->create_from_awl_table();
	$self->do("INSERT INTO $from_awl (sender_name, sender_domain, " .
		  "host_ip, last_seen) " .
		  "SELECT sender_name, sender_domain, host_ip, last_seen " .
		  "FROM $from_awl" . "old");
	$self->do("DROP TABLE $from_awl" . "old");

	# domain_awl
	$self->log(1, "CHAR -> VARCHAR in $domain_awl table");
	$self->do("ALTER TABLE $domain_awl RENAME TO $domain_awl" . "old");
	if ($db_type eq 'Pg') {
	    # we need to remove the pkey constraint
	    $self->do("ALTER TABLE $domain_awl" . "old DROP CONSTRAINT " .
		      "domain_awl_pkey");
	}
	$self->create_domain_awl_table();
	$self->do("INSERT INTO $domain_awl (sender_domain, host_ip, " .
		  "last_seen) " .
		  "SELECT sender_domain, host_ip, last_seen " .
		  "FROM $domain_awl" . "old");
	$self->do("DROP TABLE $domain_awl" . "old");

	# net_whitelist not needed anymore
	if ($self->table_exists("net_whitelist")) {
	    $self->log(1, "net_whitelist not supported anymore, " .
		       "see /etc/sqlgrey/clients_*_whitelist");
	    $self->do("DROP TABLE net_whitelist");
	}
    } else {
	$self->log(1, "SQLite treats VARCHAR and CHAR the same, " .
		   "no upgrade needed");
    }
    $self->create_config_table();
    $self->setconfig('version','1');
}

# Build a connect string for DBI
sub cnctinfo {
# Tested with PostgreSQL, MySQL and SQLite
    my $self = shift;
    my $db_type = $self->{sqlgrey}{db_type};
    my $dsn = "DBI:" . $db_type;
    # only MySQL uses database=
    if ($db_type eq 'mysql') {
        $dsn .= ":database=";
    } else {
        $dsn .= ":dbname=";
    }
    $dsn .= $self->{sqlgrey}{db_name};
    # only SQLite doesn't require a hostname
    if ($db_type ne "SQLite") {
        $dsn .= ";host=" . $self->{sqlgrey}{db_host};
    }
    return $dsn;
}

# Global DB Init code
sub initdb {
    my $self = shift;
    $self->connectdb();
    $self->database_setup();
}

sub connectdb {
    my $self = shift;
    my $db_type = $self->{sqlgrey}{db_type};
    $self->{sqlgrey}{dbh} = DBI->connect_cached($self->cnctinfo(),
						$self->{sqlgrey}{db_user},
						$self->{sqlgrey}{db_pass},
						{ PrintError => 0,
						  AutoCommit => 1 }
					       )
	or $self->log(1, "Can't connect to DB: $DBI::errstr");

    # mysql drops the connection, we have some glue code
    # to reinit the connection, but better use mysql DBD code
    if ($db_type eq 'mysql') {
        $self->{sqlgrey}{dbh}->{mysql_auto_reconnect} = 1;
    }
    # Create "now()" function for SQLite
    if ($db_type eq 'SQLite') {
        $self->{sqlgrey}{dbh}->func('now', 0, sub { return time },
				    'create_function' );
    }
}

#####################
## Table creations ##
#####################

sub create_from_awl_table {
    my $self = shift;
    $self->do("CREATE TABLE $from_awl " .
	      "(sender_name varchar(64) NOT NULL, " .
	      "sender_domain varchar(255) NOT NULL, " .
	      "host_ip varchar(15) NOT NULL, " .
	      "last_seen timestamp NOT NULL, " .
	      "PRIMARY KEY " .
	      "(sender_name, sender_domain, host_ip));")
	or mydie "Couldn't create table $from_awl: $DBI::errstr\n";
}

sub create_domain_awl_table {
    my $self = shift;
    $self->do("CREATE TABLE $domain_awl " .
	      "(sender_domain varchar(255) NOT NULL, " .
	      "host_ip varchar(15) NOT NULL, " .
	      "last_seen timestamp NOT NULL, " .
	      "PRIMARY KEY (sender_domain, host_ip));")
	or mydie "Couldn't create table $from_awl: $DBI::errstr\n";
}

sub create_connect_table {
    my $self = shift;
    # Note: no primary key, Mysql can't handle 500+ byte primary keys
    # connect should not become big enough to make it a problem
    $self->do("CREATE TABLE $connect " .
	      "(sender_name varchar(64) NOT NULL, " .
	      "sender_domain varchar(255) NOT NULL, " .
	      "ip_addr varchar(15) NOT NULL, " .
	      "rcpt varchar(255) NOT NULL, " .
	      "first_seen timestamp NOT NULL);")
	or mydie "Couldn't create table $connect: $DBI::errstr\n";
}

sub create_config_table {
    my $self = shift;
    $self->do("CREATE TABLE $config " .
	      "(parameter varchar(255) NOT NULL, " .
	      "value varchar(255), " .
	      "PRIMARY KEY (parameter));")
        or mydie "Couldn't create table $config: $DBI::errstr\n";
}

##########
## Misc ##
##########
sub class_c {
    return join('.', (split(/\./, shift))[0..2]);
}

#################
## Normalizers ##
#################

# generic single-use addresses
# normaliser
sub deverp_user {
    my $user = shift;

    ## Try to match single-use addresses
    # SRS (first and subsequent levels of forwarding)
    $user =~ s/^SRS0=[^=]+=[^=]+=([^=]+)=([^=]+)^/SRS0=#=#=$1=$2/;
    $user =~ s/^SRS1=[^=]+=([^=]+)(=+)[^=]+=[^=]+=([^=]+)=([^=]+)$/SRS1=#=$1$2#=#=$3=$4/;
    # strip extension, used sometimes for mailing-list VERP
    $user =~ s/\+.*//;
    # strip hexadecimal sequences (doable in one regexp ?)
    $user =~ s/([\._-])[0-9A-Fa-f]+([\._-])/$1#$2/g;
    #$user =~ s/^[0-9A-Fa-f]+([\._-])/#$1/g;
    $user =~ s/([\._-])[0-9A-Fa-f]+$/$1#/g;
    # Simple VERP substitution : replace numbers with '#'
    # will match VERP mailing-list message retransmissions
    #$user =~ s/\b\d+\b/#/g;

    return $user;
}

# get sender's user/domain
sub normalize_sender {
    my $self = shift;
    my $from = lc shift;
    my $empty = "-undef-";
    if ($from eq '') {
        # Probably MAILER-DAEMON talking to us
        return ("$empty","$empty","$empty")
    }
    my ($user, $domain) = split(/@/, $from, 2);
    # undefined user or domain can jeopardize SELECTs result
    # replace with invalid user/domain strings
    if (! defined $domain) {
        $domain = "$empty";
        # log : shouldn't happen
        $self->log(1, "undefined domain, from is '$from'");
    }
    if (! defined $user) {
        $user = "$empty";
        # log : shouldn't happen
        $self->log(1, "undefined user, from is '$from'");
    }

    # per RFC, user should be < 64, domain < 255
    # our database schema doesn't support more
    return (substr($user, 0, 64),substr($domain, 0, 255),
	    substr(deverp_user($user), 0, 64));
}

# make sure rcpt will be VARCHAR storable
sub normalize_rcpt {
    my $self = shift;
    my $to = lc shift;
    my ($user, $domain) = split(/@/, $to, 2);
    defined $domain or return substr($to, 0, 255);

    # trim to 255 chars ( although "$user" . "@" . "$domain"
    # can be 64 + 1 + 255, VARCHAR is 255 max)
    return substr("$user\@$domain", 0, 255);
}

##########################################
## Grey listing related database access ##
##########################################

#########
## AWLs

## Match connections to AWLs ##

sub is_in_from_awl {
    my ($self, $sender_name, $sender_domain, $host) = @_;

    # last_seen less than $self->{sqlgrey}{awl_age} days ago
    my $sth = $self->prepare_cached("SELECT 1 FROM $from_awl " .
				    "WHERE sender_name = ? " .
				    "AND sender_domain = ? " .
				    "AND host_ip = ? " .
				    "AND last_seen > now() - " .
				    $self->interval($self->{sqlgrey}{awl_age},
						    "DAY")
				   );
    if (!defined $sth or !$sth->execute($sender_name, $sender_domain, $host)) {
	$self->db_unavailable();
	$self->log(1, "Error: couldn't access $from_awl table: $DBI::errstr");
        return 1; # in doubt, accept
    } else {
	$self->db_available();
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
	return 0; # not a single entry
    } else {
	return 1; # one single entry (no multiple entries by design)
    }
}

sub is_in_domain_awl {
    my ($self, $sender_domain, $host) = @_;

    # last_seen less than $self->{sqlgrey}{awl_age} days ago
    my $sth = $self->prepare_cached("SELECT 1 FROM $domain_awl " .
				    "WHERE sender_domain = ? " .
				    "AND host_ip = ? " .
				    "AND last_seen > now() - " .
				    $self->interval($self->{sqlgrey}{awl_age},
						    "DAY")
				   );
    if (!defined $sth or !$sth->execute($sender_domain, $host)) {
	$self->db_unavailable();
	$self->log(1, "Error: couldn't access $domain_awl table: $DBI::errstr");
        return 1; # in doubt, accept
    } else {
	$self->db_available();
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
	return 0; # not a single entry
    } else {
	return 1; # one single entry (no multiple entries by design)
    }
}

## Put entries in AWLs ##

sub put_in_from_awl {
    my ($self, $sender_name, $sender_domain, $host) = @_;

    # delete old entries
    $self->do("DELETE FROM $from_awl " .
	      "WHERE sender_name = " . $self->quote($sender_name) .
	      " AND sender_domain = " . $self->quote($sender_domain) .
	      " AND host_ip = " . $self->quote($host));

    # create new entry
    $self->do("INSERT INTO $from_awl (sender_name, sender_domain, " .
	      "host_ip, last_seen) VALUES(" .
	      $self->quote($sender_name) . "," .
	      $self->quote($sender_domain) . "," .
	      $self->quote($host) . ",NOW())");
}

sub put_in_domain_awl {
    my ($self, $sender_domain, $host) = @_;

    # delete old entries
    $self->do("DELETE FROM $domain_awl " .
	      "WHERE sender_domain = " . $self->quote($sender_domain) .
	      " AND host_ip = " . $self->quote($host));

    # create new entry
    $self->do("INSERT INTO $domain_awl (sender_domain, host_ip, " .
	      "last_seen) VALUES(" .
	      $self->quote($sender_domain) . "," .
	      $self->quote($host) . ",NOW())");
}

## Update AWL entries ##

sub update_from_awl {
    my ($self, $sender_name, $sender_domain, $host) = @_;

    $self->do("UPDATE $from_awl SET last_seen = NOW() " .
	      "WHERE sender_name = " . $self->quote($sender_name) .
	      " AND sender_domain = " . $self->quote($sender_domain) .
	      " AND host_ip = " . $self->quote($host));
}

sub update_domain_awl {
    my ($self, $sender_domain, $host) = @_;

    $self->do("UPDATE $domain_awl SET last_seen = NOW() " .
	      "WHERE sender_domain = " . $self->quote($sender_domain) .
	      " AND host_ip = " . $self->quote($host));
}

# check from_awl entries for a domain/IP
sub count_from_awl {
    my ($self, $sender_domain, $host) = @_;

    my $sth = $self->prepare_cached("SELECT COUNT(*) FROM $from_awl " .
				    "WHERE sender_domain = ? AND host_ip = ?");
    if (!defined $sth or !$sth->execute($sender_domain, $host)) {
	$self->db_unavailable();
	$self->log(1, "Error: couldn't access $from_awl table: $DBI::errstr");
        return 0; # do as if table is empty
    } else {
	$self->db_available();
    }

    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
        $self->log(1, "Error: unexpected SQL result");
	return 0; # do as if table is empty
    } else {
        return $result->[0][0];
    }
}

## Cleanup AWL entries ##

sub cleanup_from_awl {
    my ($self) = @_;

    my $rows = $self->do("DELETE FROM $from_awl " .
                	 "WHERE last_seen < now() - " .
	                 $self->interval($self->{sqlgrey}{awl_age}, "DAY")
	                );

    $rows = 0 if ($rows eq '0E0');
    return $rows ? $rows : 0;
}

sub cleanup_domain_awl {
    my ($self) = @_;

    my $rows = $self->do("DELETE FROM $domain_awl " .
	                 "WHERE last_seen < now() - " .
	                 $self->interval($self->{sqlgrey}{awl_age}, "DAY")
	                );

    $rows = 0 if ($rows eq '0E0');
    return $rows ? $rows : 0;
}

sub delete_domain_from_mail_awl {
    my ($self, $domain, $host) = @_;
    $self->do("DELETE FROM $from_awl " .
	      "WHERE sender_domain = " . $self->quote($domain) .
	      " AND host_ip = " . $self->quote($host));
}

# Active domain AWL for a domain/IP
sub move_domain_from_mail_to_domain_awl {
    my ($self, $domain, $host) = @_;

    $self->put_in_domain_awl($domain, $host);
    $self->delete_domain_from_mail_awl($domain, $host);
}

############
## Connect

# check for a valid reconnection
sub in_connect {
    my ($self, $sender_name, $sender_domain, $addr, $rcpt) = @_;

    # last_seen less than $self->{sqlgrey}{max_connect_age} hours ago
    # but more than $self->{sqlgrey}{reconnect_delay} minutes ago
    my $query = "SELECT 1 FROM $connect " .
            	"WHERE sender_name = ? AND sender_domain = ? " .
	        "AND ip_addr = ? AND rcpt = ? " .
		"AND first_seen BETWEEN now() - " .
		$self->interval($self->{sqlgrey}{max_connect_age},
				"HOUR") .
		" AND now() - " .
		$self->interval($self->{sqlgrey}{reconnect_delay},
				"MINUTE");
    my $sth = $self->prepare_cached($query);
    if (!defined $sth or !$sth->execute($sender_name, $sender_domain, $addr, $rcpt)) {
	$self->db_unavailable();
        $self->log(1, "Error: couldn't access $connect table: $DBI::errstr");
        return 1; # in doubt, accept
    } else {
	$self->db_available();
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
	return 0; # not a single entry
    } else {
	return 1; # one single entry (no multiple entries by design)
    }
}

# check for early reconnection
sub recently_in_connect {
    my ($self, $sender_name, $sender_domain, $addr, $rcpt) = @_;

    # last_seen less than $self->{sqlgrey}{reconnect_delay} minutes ago
    my $query = "SELECT 1 FROM $connect WHERE sender_name = ? " .
	        "AND sender_domain = ? " .
        	"AND ip_addr = ? AND rcpt = ? " .
	        "AND first_seen >= now() - " .
		$self->interval($self->{sqlgrey}{reconnect_delay},
				"MINUTE");
    my $sth = $self->prepare_cached($query);
    if (!defined $sth or !$sth->execute($sender_name, $sender_domain, $addr, $rcpt)) {
	$self->db_unavailable();
        $self->log(1, "Error: Couldn't access $connect table: $DBI::errstr");
        return 0; # in doubt, accept
    } else {
	$self->db_available();
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
	return 0; # not a single entry
    } else {
	return 1; # one single entry (no multiple entries by design)
    }
}

# add a first attempt
sub put_in_connect {
    my ($self, $sender_name, $sender_domain, $addr, $rcpt) = @_;

    # delete old entries
    $self->do("DELETE FROM $connect " .
	      "WHERE sender_name = " . $self->quote($sender_name) .
	      " AND sender_domain = " . $self->quote($sender_domain) .
	      " AND ip_addr = " . $self->quote($addr) .
	      " AND rcpt = " . $self->quote($rcpt));

    # create new entry
    $self->do("INSERT INTO $connect (sender_name, sender_domain, " .
	      "ip_addr, rcpt, first_seen) " .
	      "VALUES(" .
	      $self->quote($sender_name) . "," .
	      $self->quote($sender_domain) . "," .
	      $self->quote($addr) . "," .
	      $self->quote($rcpt) . ", NOW())");
}

# For logging purpose
sub get_reconnect_delay {
    my ($self, $sender_name, $sender_domain, $addr, $rcpt) = @_;

    my $query;
    if ($self->{sqlgrey}{db_type} eq 'mysql') {
        $query = "SELECT SEC_TO_TIME(UNIX_TIMESTAMP(NOW())-" .
	                            "UNIX_TIMESTAMP(first_seen)) " .
		 "FROM $connect ";
    } else {
        $query = "SELECT now() - first_seen FROM $connect ";
    } 
    $query .= "WHERE sender_name = ? AND sender_domain = ? " .
	      "AND ip_addr = ? AND rcpt = ?";
    my $sth = $self->prepare_cached($query);
    if (!defined $sth or !$sth->execute($sender_name, $sender_domain, $addr, $rcpt)) {
	$self->db_unavailable();
        $self->log(1, "Error: couldn't get reconnect delay: $DBI::errstr");
        return "sql error";
    } else {
	$self->db_available();
    }
    my $result = $sth->fetchall_arrayref();
    if ($#$result != 0) {
        $self->log(1, "Error: no connect in database for " .
		      "$sender_name\@$sender_domain, $addr, $rcpt");
	return "error: nothing in connect";
    } else {
        return $result->[0][0];
    }
}

# Clean connect entries for a whitelisted mail/IP
sub delete_mail_ip_from_connect {
    my ($self, $sender_name, $sender_domain, $addr) = @_;

    $self->do("DELETE FROM $connect " .
	      "WHERE sender_name = " . $self->quote($sender_name) .
	      " AND sender_domain = " . $self->quote($sender_domain) .
	      " AND ip_addr = " . $self->quote($addr));
}

# clean probable SPAM attempts and log them
sub cleanup_connect {
    my $self = shift;
    my $max_connect_age = $self->{sqlgrey}{max_connect_age};

    if ($self->{server}{log_level} >= 2) {
        # Print probable SPAM:
        my $query = "SELECT sender_name, sender_domain, ip_addr, " .
                    "rcpt, first_seen " .
                    "FROM $connect " .
                    "WHERE first_seen < now() - " .
                    $self->interval($max_connect_age, "HOUR");
        my $sth = $self->prepare_cached($query);
        if (defined $sth and $sth->execute()) {
	    $self->db_available();
	    my $result = $sth->fetchall_arrayref();
	    for my $spam (@{$result}) {
	        $self->log(2, "Probable spam: $$spam[2]: " .
	   	           "$$spam[0]\@$$spam[1] -> " .
		           "$$spam[3] at $$spam[4]");
	    }
        } else {
	    $self->db_available();
	    $self->log(1, "Error: couldn't list detected spam attempts");
        }
    }
    my $rows = $self->do("DELETE FROM $connect " .
	                 "WHERE first_seen < now() - " .
	                 $self->interval($max_connect_age, "HOUR")
	                );

   # DBI returns 0E0 if no rows is affected.
   $rows = 0 if ($rows eq '0E0');

   return $rows ? $rows : 0;
}

## General cleanup
sub cleanup {
    my ($self) = @_;
    my $time = time();
    my $frows = $self->cleanup_from_awl();
    my $drows = $self->cleanup_domain_awl();
    my $crows = $self->cleanup_connect();
    $time = time() - $time;
    $self->log(2, 'Spent ' . $time . "s cleaning: from_awl ($frows) domain_awl ($drows) connect ($crows)");
}

##################
## Whitelisting ##
##################

sub init_whitelists {
    my $self = shift;
    $self->read_ip_whitelists();
    $self->read_fqdn_whitelists();
    # check dynamic files' mtime
    $self->{sqlgrey}{dyniptime} = get_mtime($dyn_ip_whitelist_file);
    $self->{sqlgrey}{dynfqdntime} = get_mtime($dyn_fqdn_whitelist_file);
}

sub read_ip_whitelists {
    my $self = shift;
    $self->read_static_ip_whitelist();
    $self->read_dyn_ip_whitelist();
}

sub read_fqdn_whitelists {
    my $self = shift;
    $self->read_static_fqdn_whitelist();
    $self->read_dyn_fqdn_whitelist();
}

sub read_static_ip_whitelist {
    my $self = shift;
    $self->{sqlgrey}{stat_ip_whitelist} =
	$self->read_an_ip_whitelist($stat_ip_whitelist_file);
}

sub read_dyn_ip_whitelist {
    my $self = shift;
    $self->{sqlgrey}{dyn_ip_whitelist} =
	$self->read_an_ip_whitelist($dyn_ip_whitelist_file);
}

sub read_an_ip_whitelist {
    my $self = shift;
    my $file = shift;
    # Prepare empty whitelist
    my $whitelist;
    $whitelist->{IP} = {};
    $whitelist->{C} = {};
    if (! open (FILE, '<' . $file)) {
	$self->log(1, "Warning: $file not found or unreadable");
	return $whitelist;
    }
    while (<FILE>) {
	chomp;
	# strip comments
	s/#.*//;
	# strip spaces
	s/\s+//;
	# Anything left ?
	next unless length;
	if (/^\d+\.\d+\.\d+\.\d+$/) {
	    $whitelist->{IP}{$_} = '';
	    next;
	} elsif (/^\d+\.\d+\.\d+$/) {
	    $whitelist->{C}{$_} = '';
	    next;
	} else {
	    $self->log(1,"Unrecognised line in $file: $_");
	}
    }
    close FILE;
    return $whitelist;
}

sub read_static_fqdn_whitelist {
    my $self = shift;
    $self->{sqlgrey}{stat_fqdn_whitelist} =
	$self->read_an_fqdn_whitelist($stat_fqdn_whitelist_file);
}

sub read_dyn_fqdn_whitelist {
    my $self = shift;
    $self->{sqlgrey}{dyn_fqdn_whitelist} =
	$self->read_an_fqdn_whitelist($dyn_fqdn_whitelist_file);
}

sub read_an_fqdn_whitelist {
    my $self = shift;
    my $file = shift;

    # Prepare empty whitelists
    my $whitelist;
    my @re_whitelist;
    my @domain_whitelist;
    my $system_whitelist;

    if (! open (FILE, '<' . $file)) {
	$self->log(1, "Warning: $file not found or readable");
	$whitelist->{system} = $system_whitelist;
	$whitelist->{domain} = \@domain_whitelist;
	$whitelist->{regexp} = \@re_whitelist;
	return $whitelist;
    }
    while (<FILE>) {
	chomp;
	# strip comments and whitespaces
	s/#.*//; s/\s+//;
	# Anything left ?
	next unless length;
	if (/\/(\S+)\/$/) { # regexp
	    push @re_whitelist, $1;
	} elsif (/^\*\.(.*$)/) { # whole domain
	    push @domain_whitelist, $1;
	} elsif (/^([\w-]+\.)+[\w-]+$/) { # looks like a system name
	    $system_whitelist->{$_} = 1;
	} else {
	    $self->log(1, "Unrecognised line in $file: $_");
	}
    }
    close FILE;
    $whitelist->{system} = $system_whitelist;
    $whitelist->{domain} = \@domain_whitelist;
    $whitelist->{regexp} = \@re_whitelist;
    return $whitelist;
}

sub update_dyn_whitelists {
    my $self = shift;
    $self->update_dyn_ip_whitelist();
    $self->update_dyn_fqdn_whitelist();
}

# Set the reload flag
sub mark_reload_request {
    $reload = 1;
}

# When not in the middle of a processing...
# check the reload flag
sub got_reload_request {
    my $myreload = $reload eq 1;
    $reload = 0;
    return ($myreload);
}

sub update_static_whitelists {
    my $self = shift;
    $self->log(1,"reloading static whitelists");
    $self->read_static_ip_whitelist();
    $self->read_dyn_fqdn_whitelist();
}

sub get_mtime {
    my $file = shift;
    # file exists ?
    if (stat($file)) {
	# return mtime
	return (stat(_))[9];
    } else {
	return 0;
    }
}

sub update_dyn_ip_whitelist {
    my $self = shift;
    my $dyntime = get_mtime($dyn_ip_whitelist_file);
    if ($dyntime > $self->{sqlgrey}{dyniptime}) {
	$self->log(1,"reloading $dyn_ip_whitelist_file");
	$self->{sqlgrey}{dyniptime} = $dyntime;
	$self->read_dyn_ip_whitelist();
    }
}

sub update_dyn_fqdn_whitelist {
    my $self = shift;
    my $dyntime = get_mtime($dyn_fqdn_whitelist_file);
    if ($dyntime > $self->{sqlgrey}{dynfqdntime}) {
	$self->log(1,"reloading $dyn_fqdn_whitelist_file");
	$self->{sqlgrey}{dynfqdntime} = $dyntime;
	$self->read_dyn_fqdn_whitelist();
    }
}

sub is_in_whitelists {
    ## expects all parameters
    ## for rcpt_whitelists for example
    my ($self, $sender_name, $sender_domain, $ip, $fqdn, $rcpt) = @_;
    return ($self->is_in_ip_whitelists($ip) or
	$self->is_in_fqdn_whitelists($fqdn));
}

sub is_in_ip_whitelists {
    my ($self, $ip) = @_;
    return ($self->is_in_static_ip_whitelist($ip)
	or $self->is_in_dyn_ip_whitelist($ip));
}

sub is_in_fqdn_whitelists {
    my ($self, $fqdn) = @_;
    return ($self->is_in_static_fqdn_whitelist($fqdn)
	or $self->is_in_dyn_fqdn_whitelist($fqdn));
}

sub is_in_static_ip_whitelist {
    my ($self, $ip) = @_;

    return (defined $self->{sqlgrey}{stat_ip_whitelist}->{IP}{$ip}
	or defined $self->{sqlgrey}{stat_ip_whitelist}->{C}{class_c($ip)});
}

sub is_in_dyn_ip_whitelist {
    my ($self, $ip) = @_;
    return (defined $self->{sqlgrey}{dyn_ip_whitelist}->{IP}{$ip}
	or defined $self->{sqlgrey}{dyn_ip_whitelist}->{C}{class_c($ip)});
}

sub is_in_static_fqdn_whitelist {
    my ($self, $fqdn) = @_;
    return is_in_fqdn_whitelist($fqdn,
				$self->{sqlgrey}{stat_fqdn_whitelist});
}

sub is_in_dyn_fqdn_whitelist {
    my ($self, $fqdn) = @_;
    return is_in_fqdn_whitelist($fqdn,
				$self->{sqlgrey}{dyn_fqdn_whitelist});
}

sub is_in_fqdn_whitelist {
    my ($fqdn, $whitelist) = @_;
    # check hostnames
    if (defined $whitelist->{system}->{$fqdn}) {
	return 1;
    }
    # check domains
    foreach my $domain (@{$whitelist->{domain}}) {
	if ($fqdn =~ /\.$domain$/) {
	    return 1;
	}
    }
    # check regexps
    foreach my $regexp (@{$whitelist->{regexp}}) {
	if ($fqdn =~ /$regexp/) {
	    return 1;
	}
    }
    # Nothing matches
    return 0;
}

## class-C based greylisting
sub client_identifier {
    my ($self, $addr, $fqdn) = @_;
    my $greymethod = $self->{sqlgrey}{greymethod};
    my $classc = class_c($addr);

    if ($greymethod eq 'full') {
	return $addr;
    } elsif ($greymethod eq 'classc') {
	return $classc;
    } elsif ($greymethod eq 'smart') {
	# check $fqdn
	# no fqdn, treat as suspicious
	return $addr if $fqdn eq 'unknown';
	my @bytes = split(/\./, $addr);
	# we need the last byte
	return $addr unless defined $bytes[3];
	# if last bytes are in fqdn, assume home-user address
	return $addr if $fqdn =~ /$bytes[3]/ and $fqdn =~ /$bytes[2]/;
	return $classc;
    }
}

# main routine:
# based on attributes specified as argument, return policy decision
sub smtpd_access_policy($$)
{
    my ($self, $attr) = @_;

    # Rejection codes
    my $reject_first = $self->{sqlgrey}{reject_first};
    my $reject_early = $self->{sqlgrey}{reject_early};

    # prepare lookup
    my ($sender_name,$sender_domain,$deverp_sender_name) =
	$self->normalize_sender($attr->{sender});
    my $recipient = $self->normalize_rcpt($attr->{recipient});
    my $addr = $attr->{client_address};
    my $fqdn = $attr->{client_name};

    # Is it time for cleanups ?
    if (time() > $self->{sqlgrey}{next_maint}) {
        # $self->log(4, "Maintenance delay expired: cleanup triggered");
        $self->cleanup();
        $self->{sqlgrey}{next_maint} = time() + $self->{sqlgrey}{db_cleandelay};
    }
    # Check for new whitelists
    $self->update_dyn_whitelists();
    # Check if we got the reload signal.
    # We can't process this signal as soon as we receive it as
    # we may be using variables for which it will trigger an update
    $self->got_reload_request() and $self->update_static_whitelists();

    # whitelist check
    if ($self->is_in_whitelists($sender_name, $sender_domain,
			       $addr, $fqdn, $recipient)) {
	$self->log(3, "whitelist: $sender_name\@$sender_domain, $addr($fqdn) $recipient");
        return $self->{sqlgrey}{prepend} ?
	    $prepend . 'whitelisted by ' . $software
	    : 'dunno';
    }

    my $cltid = $self->client_identifier($addr, $fqdn);
    # domain scale awl check
    if ($self->is_in_domain_awl($sender_domain, $cltid)) {
	$self->log(3, "domain_awl-match: updating $sender_domain, $cltid");
	# update awl entry
	$self->update_domain_awl($sender_domain, $cltid);
	return $self->{sqlgrey}{prepend} ?
	    $prepend . 'domain auto-whitelisted by ' . $software
	    : 'dunno';
    }
    # address scale awl check
    if ($self->is_in_from_awl($deverp_sender_name, $sender_domain, $cltid)) {
	$self->log(3, "from_awl-match: updating $cltid: " .
		      "$sender_name\@$sender_domain");
	# update awl entry
	$self->update_from_awl($deverp_sender_name, $sender_domain, $cltid);
	return $self->{sqlgrey}{prepend} ?
	    $prepend . 'from auto-whitelisted by ' . $software
	    : 'dunno';
    }
    # is it an early reconnect ?
    if ($self->recently_in_connect($sender_name, $sender_domain,
				   $cltid, $recipient)) {
        $self->log(2, "reconnect too early: $cltid: " .
	 	      "$sender_name\@$sender_domain -> $recipient");
	$self->log(4, "Rejecting with: $reject_early  Greylisted for " .
	           $self->{sqlgrey}{reconnect_delay} . " minutes");
	return "$reject_early Greylisted for " .
	    $self->{sqlgrey}{reconnect_delay} . " minutes";
    }
    # is it a reconnection ?
    if ($self->in_connect($sender_name, $sender_domain, $cltid, $recipient)) {
	my $delay = $self->get_reconnect_delay($sender_name, $sender_domain,
					       $cltid, $recipient);
        $self->log(2, "$cltid: $sender_name" . "\@" . $sender_domain .
		      " -> $recipient: reconnect($delay) ok, adding to AWL");
	# check if we have others from the same domain in the from_awl
	# add 1 for our sample and compare to the aggregation level
	if (
	    ($self->{sqlgrey}{domain_level} != 0)
	    and
	    ($self->count_from_awl($sender_domain, $cltid)+1 >=
	     $self->{sqlgrey}{domain_level})
	   ) {
	    # use domain-level AWL
	    $self->move_domain_from_mail_to_domain_awl($sender_domain,
						       $cltid);
	    $self->log(2, "$cltid,$sender_domain reached " .
		           $self->{sqlgrey}{domain_level} .
		           ", using domain-level AWL now");
	} else {
	    # add to mail-level AWL
	    $self->log(2, "$deverp_sender_name" . "\@" . "$sender_domain: " .
		          "$cltid added to mail-level AWL");
	    $self->put_in_from_awl($deverp_sender_name, $sender_domain, $cltid);
	}
	$self->delete_mail_ip_from_connect($sender_name, $sender_domain,
					   $cltid);
	return $self->{sqlgrey}{prepend} ?
	    $prepend . "delayed $delay by $software" : 'dunno';
    }
    # new connection
    $self->log(2, "new: $cltid: $sender_name\@$sender_domain -> $recipient");
    $self->put_in_connect($sender_name, $sender_domain, $cltid, $recipient);
    $self->log(4, "Rejecting with: $reject_first  Greylisted for " .
	$self->{sqlgrey}{reconnect_delay} . " minutes");
    return "$reject_first Greylisted for " .
	$self->{sqlgrey}{reconnect_delay} . " minutes";
}

sub read_conffile
{
    my $optional_file = shift;
    if (defined $optional_file) {
	$config_file = $optional_file;
    }
    # Check if conf file is readable if explicitly told to use one
    if (defined $optional_file) {
	open(CONF, '<' . $config_file)
	    or die "Couldn't open $config_file for reading: $!\n";
    } else {
	open(CONF, '<' . $config_file)
	    or return;
    }

    while (<CONF>) {
        chomp;          # no newline
        s/#.*//;        # no comments
        s/^\s+//;       # no leading white
        s/\s+$//;       # no trailing white
        next unless length;     # anything left ?
        my ($var, $value) = split(/\s*=\s*/, $_, 2);
        $dflt{$var} = $value;
	if (! defined $value) {
	    $dflt{$var} = 1;
	}
    }
    close CONF
	or die "Couldn't close config file $config_file\n";
}

sub help {
    pod2usage(1);
}

# Setup the environment
sub main()
{
    # save arguments for Net:Server HUP restart
    my @ARGV_saved = @ARGV;

    # options parsing
    my %opt = ();
    GetOptions(\%opt, 'help|h', 'man', 'version', 'configfile|f=s',
	'verbose|v', 'quiet|q', 'debug','daemonize|d', 'inet|i=i',
	'user|u=s', 'group=s', 'pidfile|p=s', 'reconnect-delay|r=i',
        'max-connect-age|m=i', 'awl-age|a=i','group-domain-level|g=i',
        'db-type=s', 'db-name=s', 'db-host=s', 'db-user=s', 'db-pass=s',
        'db-cleandelay=i', 'kill|k', 'prepend=i', 'greymethod=s')
	or exit(1);

    if ($opt{help})    { help() }
    if ($opt{man})     { pod2usage(-exitstatus => 0, -verbose => 2) }
    if ($opt{version}) { print "sqlgrey $VERSION\n"; exit(0) }

    # Read the config file
    read_conffile($opt{configfile});

    # Are we on a killing spray ?
    if (defined $opt{kill}) {
	my $pidfile = $opt{pidfile} ? $opt{pidfile} : $dflt{pidfile};
	open(PIDFILE, '<' . $pidfile)
	    or mydie "Coudn't read pidfile: $pidfile\n";
	while (<PIDFILE>) { # should only have one pid
	    kill 15, $_;
	}
	close PIDFILE;
	unlink $pidfile;
	exit;
    }

    # bind only localhost if no host is specified
    if(defined $opt{inet} and $opt{inet}=~/^\d+$/) {
        $opt{inet} = "localhost:$opt{inet}";
    } elsif(defined $dflt{inet} and $dflt{inet}=~/^\d+$/) {
        $dflt{inet} = "localhost:$dflt{inet}";
    }

    my $loglevel = 2;
    if (defined $opt{debug}) {
	$loglevel = 4;
    } elsif (defined $opt{verbose}) {
	$loglevel = 3;
    } elsif (defined $opt{quiet}) {
	$loglevel = 1;
    } elsif (defined $dflt{debug}) {
	$loglevel = 4;
    } elsif (defined $dflt{verbose}) {
	$loglevel = 3;
    } elsif (defined $dflt{quiet}) {
	$loglevel = 1;
    }

    # set the actual reject code values
    if ($dflt{reject_first_attempt} eq 'delay') {
    	$dflt{reject_first_attempt} = 'defer_if_permit';
    } elsif ($dflt{reject_first_attempt} eq 'immed') {
	$dflt{reject_first_attempt} = '450';
    } else {
    	pod2usage(1);
    }
    if (defined $dflt{reject_early_reconnect}) {
	if ($dflt{reject_early_reconnect} eq 'delay') {
	    $dflt{reject_early_reconnect} = 'defer_if_permit';
	} elsif ($dflt{reject_early_reconnect} eq 'immed') {
	    $dflt{reject_early_reconnect} = '450';
	} else {
	    pod2usage(1);
	}
    }
    
    # used 2 times in the following struct
    my $cleandelay = $opt{'db-cleandelay'} || $dflt{db_cleandelay};
    # create Net::Server object and run it
    my $server = bless {
        server => {
            commandline     => [ $0, @ARGV_saved ],
            port            => [ $opt{inet} || $dflt{inet} ],
            proto           => 'tcp',
            user            => $opt{user} || $dflt{user},
	    group           => $opt{group} || $dflt{group},
            setsid          => $opt{daemonize} ? 1 : undef,
            pid_file        => $opt{daemonize} ?
		   $opt{pidfile} ? $opt{pidfile} : $dflt{pidfile}
		   : undef,
            log_level       => $loglevel,
            log_file        => $opt{daemonize} ? 'Sys::Syslog' : undef,
            syslog_facility => 'mail',
            syslog_logsock  => 'unix',
            syslog_ident    => 'sqlgrey',
	    syslog_logopt   => 'cons',
        },
        sqlgrey => {
	    # min time before reconnect (min)
            reconnect_delay => $opt{'reconnect-delay'}
                 		    || $dflt{reconnect_delay},
	    # max time before reconnect (hour)
            max_connect_age => $opt{'max-connect-age'}
		                    || $dflt{max_connect_age},
	    # How long is an AWL entry valid (days)
            awl_age         => $opt{'awl-age'} || $dflt{awl_age},
	    # How many from match a domain/IP before a switch to domain AWL
	    domain_level    => $opt{'group-domain-level'}
		                   || $dflt{group_domain_level},
            next_maint      => time + $cleandelay,
	    db_cleandelay   => $cleandelay, # between table cleanups (seconds)

            db_type         => $opt{'db-type'} || $dflt{db_type},
            db_name         => $opt{'db-name'} || $dflt{db_name},
            db_host         => $opt{'db-host'} || $dflt{db_host},
	    db_user         => $opt{'db-user'} || $dflt{db_user},
            db_pass         => $opt{'db-pass'} || $dflt{db_pass},
	    db_available    => 1, # used to trigger e-mails
	    prepend         => $opt{prepend}   || $dflt{prepend},
	    greymethod      => $opt{greymethod} || $dflt{greymethod},
	    reject_first    => $dflt{reject_first_attempt},
	    reject_early    => $dflt{reject_early_reconnect}
	    			|| $dflt{reject_first_attempt},
	    admin_mail      => $dflt{admin_mail},
	    warn_db         => 0, # mask SQL errors during db init
	    mail_maxbucket  => 10, # max burst of mails
	    mail_period     => 10, # one mail each 10 minutes max
	    mail_bucket     => 5, # initial bucket
	    last_mail       => time,
        },
    }, 'sqlgrey';

    my $greymethod = $server->{sqlgrey}{greymethod};
    if ($greymethod ne 'smart' and $greymethod ne 'full' and
	$greymethod ne 'classc') {
	pod2usage(1);
    }
    $server->run;
}

####################################
## Net::Server::Multiplex methods ##
####################################

# Called before the first query comes.
sub pre_loop_hook() {
    my $self = shift;

    # be sure to put in syslog any warnings / fatal errors
    if($self->{server}{log_file} eq 'Sys::Syslog') {
        $SIG{__WARN__} = sub {Sys::Syslog::syslog('warning', "warning: $_[0]")};
        $SIG{__DIE__}  = sub {Sys::Syslog::syslog('crit', "fatal: $_[0]");
			      die @_;};
    }

    $SIG{USR1} = \&mark_reload_request;

    $self->initdb();
    $self->log(4, "Initial cleanup");
    $self->cleanup();
    $self->init_whitelists();

    if (defined $self->{server}{setsid}) {
        # Detach from terminal
        close(STDIN);
        close(STDOUT);
        close(STDERR);
	# Ugly hack to prevent perl from complaining
	# 'warning: Filehandle STDERR reopened as FILE only \
	# for input at /usr/bin/sqlgrey line 717, <FILE> line 57'
	open(STDIN,'</dev/null');
	open(STDOUT,'>/dev/null');
	open(STDERR,'>/dev/null');
    }
}

sub restart_open_hook() {
    my $self = shift;
    my $pidfile = $self->{server}{pid_file};
    unlink $pidfile;
}

sub restart_close_hook() {
    my $self = shift;

    # SIGHUP triggers the whitelist reloading
    $self->mark_reload_request();
}

# Main muxer :
# reads a line at a time, call smtpd_access_policy if the input looks valid
# and return the result
sub mux_input()
{
    my ($self, $mux, $fh, $in_ref) = @_;
    defined $self->{sqlgrey_attr} or $self->{sqlgrey_attr} = {};
    my $attr = $self->{sqlgrey_attr};

    # consume entire lines
    while ($$in_ref =~ s/^([^\n]*)\n//) {
        next unless defined $1;
        my $in = $1;
        if($in =~ /([^=]+)=(.*)/) {
            # read attributes
            $attr->{substr($1, 0, 512)} = substr($2, 0, 512);
        }
        elsif($in eq '') {
            defined $attr->{request} or $attr->{request}='';
            if($attr->{request} ne 'smtpd_access_policy') {
                $self->{net_server}->log(1, "unrecognized request type: " .
					    "'$attr->{request}'");
            }
            else {
                # decide
                my $action = $self->{net_server}->smtpd_access_policy($attr);
                # debug
                if($self->{net_server}{server}{log_level}>=4) {
                    my $a = 'request: ';
                    $a .= join(' ', map {"$_=$attr->{$_}"} (sort keys %$attr));
                    $a .= " action=$action";
                    $self->{net_server}->log(1, $a);
                }
                # give answer
                print $fh "action=$action\n\n";
            }
            $self->{sqlgrey_attr} = {};
        }
        else {
             $self->{net_server}->log(1, "ignoring garbage: <" .
				         substr($in, 0, 100).">");
        }
    }
}

main;

__END__

=head1 NAME

sqlgrey - Postfix Greylisting Policy Server

=head1 SYNOPSIS

B<sqlgrey> [I<options>...]

 -h, --help                 display this help and exit
     --man                  display man page
     --version              output version information and exit
*-q  --quiet                only log errors
*-v, --verbose              increase log level
*    --debug                further increase log level
*-i, --inet=[HOST:]PORT     listen on PORT, localhost if HOST is not
                            specified (default localhost:2501)
*-a, --awl-age=N            connection is valid N days in auto-white-list
                            (default: 60)
*-g, --group-domain-level=N if N email adresses from the same IP and the
                            same domain are in AWL, the whole domain is
                            put in AWL, 0 disables (default: 2)
 -d, --daemonize            run in the background
*-p, --pidfile=PATH         put daemon pid into this file
                            (default: /var/run/sqlgrey.pid)
*-u, --user=USER            run as USER (default: sqlgrey)
*-r, --reconnect-delay=N    greylist (refuse mail) for N minutes after
                            first connection (default: 1)
*-m, --max-connect-age=N    mail transfer attempt is forgotten N hours
                            after (default: 24)
*    --greymethod=[full|classc|smart]
                            How to greylist, default: smart
*    --db-type=TYPE         DBD driver to use (mysql, Pg and SQLite are
                            tested (default: Pg)
*    --db-host=HOSTNAME     default: localhost
*    --db-name=NAME         default: sqlgrey
*    --db-user=USER         default: sqlgrey
*    --db-pass=PASS         default: '' (empty password)
*    --db-cleandelay=N	    delay between table cleanups in seconds
     			    (default: 1800, 30 minutes)
*    --prepend=[1|0]        default: 1 (add X-Greylist: headers)
 -k, --kill                 kill a running sqlgrey
                            (identified by 'pidfile' content)
 -f, --configfile=FILE      read config from FILE (default /etc/sqlgrey.conf)
                            expecting config_param=value lines,
                            - spaces are ignored,
                            - '#' is used for comments
                            - parameter names using '-' (dash) on commandline
                              use '_' (underscore)in config file
                            - not supported in config file:
                              help, version, man, daemonize, kill, configfile
                            - verbose mode activated with "verbose = 1"
                            example:
                            -------------------------------------------------
                            # SQLgrey conf file
                            db_name = other_sqlgreydb
                            inet = 25001           # bind on localhost:25001
                            group_domain_level = 0 # no domain AWL
                            -------------------------------------------------

[*] these parameters are deprecated, please use the configfile. See the
example packaged configfile for details and default values.

=head1 DESCRIPTION

Sqlgrey is a Postfix policy server implementing greylisting.

When a request for delivery of a mail is received by Postfix via SMTP,
the triplet C<CLIENT_IP> / C<SENDER> / C<RECIPIENT> is built. If it is
the first time that this triplet is seen, or if the triplet was first
seen less than I<reconnect-delay> minutes (1 is the default), then
the mail gets rejected with a temporary error. Hopefully spammers or
viruses will not try again later, as it is however required per RFC.

In order to alleviate the reconnect delay, sqlgrey uses a 2-level
auto-white-list (AWL) system:

=over 4

=item *

As soon as a C<CLIENT IP> / C<SENDER> is accepted, it is added to an
AWL. The couple expires when it isn't seen for more than I<awl-age>
days (60 is the default).

=item *

If I<group-domain-level> C<SENDER>s (2 is the default) from the same
domain or more use the same C<CLIENT IP>, another AWL is used based on a
C<CLIENT IP> / C<DOMAIN> couple.
This couple expires after awl-age days too. This AWL is meant to be used
on high throughput sites in order to :

=over 4

=item *

minimize the amount of data stored in database,

=item *

minimize the amount of processing required to find an entry in the AWL.

=item * 

don't impose any further mail delay when a C<CLIENT IP> / C<DOMAIN>
couple is known.

=back

It can be disabled by setting I<group-domain-level> to 0.

=back

General idea:

When a SMTP client has been accepted once, if the IP isn't dynamic,
greylisting the IP again is only a waste of time when it sends another
e-mail. As we already know that this IP runs an RFC-compliant MTA (at
least the 4xx error code handling) and will get the new e-mail through
anyway.

In the case of mail relays, these AWLs works very well as the same
senders and mail domains are constantly coming through the same IP
addresses -E<gt> the e-mails are quickly accepted on the first try.
In the case of individual SMTP servers, this works well if the IP is
fixed too.
When using a floating IP address, the AWLs are defeated, but it should
be the least common case by far.

Why do we put the domain in the AWL and not the IP only ? If we did
only store IP addresses, polluting the AWL would be far too easy. It
would only take one correctly configured MTA sending one e-mail from
one IP one single time to put it in a whitelist used whatever future
mails from this IP look like.

With this AWL system, one single mail can only allow whitelisting of
mails from a single sender from the same IP...

=head1 INSTALLATION

=over 4

=item *

Create a C<sqlgrey> user. This will be the user the daemon runs as.

=item *

When using a full-fledge SGBD (MySQL and PostgreSQL, not SQLite),
create a 'sqlgrey' db user and a 'sqlgrey' database. Grant access
to the newly created database to sqlgrey.

=item *

Use the packaged init script to start sqlgrey at boot and start it
manually.

=back

=head1 CONFIGURATION

=head2 General

=over 4

=item *

Start by adding check_policy_service after reject_unauth_destination in
/etc/postfix/main.cf :

 smtpd_recipient_restrictions =
               ...
               reject_unauth_destination
               check_policy_service inet:127.0.0.1:2501

=item *

Be aware that some servers do not behave correctly and do not resend
mails (as required by the standard) or use unique return addresses.
This is the reason why you should maintain whitelists for them.

SQLgrey comes with a comprehensive whitelisting system. It can
even be configured to fetch uptodate whitelists from a repository. See
the HOWTO for the details.

=back

=head2 Disabling greylisting for some users

If you want to disable greylisting for some users you can configure
Postfix like this:

/etc/postfix/sqlgrey_recipient_access:
  i_like_spam@ee.ethz.ch                OK

Then you'll add a check_recipient_access in main.cf before the
check_policy_service :
 smtpd_recipient_restrictions =
       ...
       reject_unauth_destination
       check_client_access    hash:/etc/postfix/sqlgrey_client_access
       check_recipient_access hash:/etc/postfix/sqlgrey_recipient_access
       check_policy_service inet:127.0.0.1:10023

=head1 SEE ALSO

See L<http://www.greylisting.org/> for a description of what greylisting
is and L<http://www.postfix.org/SMTPD_POLICY_README.html> for a
description of how Postfix policy servers work.

=head1 COPYRIGHT

Copyright (c) 2004 by Lionel Bouton.

=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

=head1 AUTHOR

S<Lionel Bouton E<lt>lionel-dev@bouton.nameE<gt>>

=cut

# Emacs Configuration
#
# Local Variables:
# mode: cperl
# eval: (cperl-set-style "PerlStyle")
# mode: flyspell
# mode: flyspell-prog
# End:
#
# vi: sw=4 et
